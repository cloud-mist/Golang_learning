## 1.任务概述
&emsp;&emsp;人工智能技术的应用领域日趋广泛，新的智能应用层出不穷。本项目将利用人工智能技术来对蝴蝶图像进行分类，需要能对蝴蝶的类别、属性进行细粒度的识别分类。相关研究工作者能够根据采集到的蝴蝶图片，快速识别图中蝴蝶的种类。期望能够有助于提升蝴蝶识别工作的效率和精度。
## 2.创建项目和挂载数据 
&emsp;&emsp;数据集都来源于网络公开数据（和鲸社区）。图片中所涉及的蝴蝶总共有9个属，20个物种，文件genus.txt中描述了9个属名，species.txt描述了20个物种名。

 &emsp;&emsp;在创建项目时，可以为该项目挂载Butterfly20蝴蝶数据集，即便项目重启，该挂载的数据集也不会被自动清除。具体方法如下：首先采用notebook方式构建项目，项目创建框中的最下方有个数据集选项，选择“+添加数据集”。然后，弹出搜索框，在关键词栏目输入“bufferfly20”，便能够查询到该数据集。最后，选中该数据集，可以自动在项目中挂载该数据集了。

 &emsp;&emsp;需要注意的是，每次重新打开该项目，data文件夹下除了挂载的数据集，其他文件都将被删除。

 &emsp;&emsp;被挂载的数据集会自动出现在data目录之下，通常是压缩包的形式。在data/data63004目录，其中有两个压缩文件，分别是Butterfly20.zip和Butterfly20_test.zip。也可以利用下载功能把数据集下载到本地进行训练。
## 3.蝴蝶数据集
我们看看蝴蝶图像数据长什么样子？

- 首先，解压缩数据。以下几个步骤：
  1. 把当前路径转换到data目录，可以使用命令!cd data。在AI studio nootbook中可以使用Linux命令，需要在命令的最前面加上英文的感叹号(!)。用&&可以连接两个命令。用\号可以换行写代码。需要注意的是，每次重新打开该项目，data文件夹下除了挂载的数据集，其他文件都会被清空。因此，如果把数据保存在data目录中，每次重新启动项目时，都需要解压缩一下。如果想省事持久化保存，可以把数据保存在work目录下。实际上，!加某命令的模式，等价于python中的get_ipython().system('某命令')模式。

  2. 利用unzip命令，把压缩包解压到当前路径。unzip的-q参数代表执行时不显示任何信息。unzip的-o参数代表不必先询问用户，unzip执行后覆盖原有的文件。两个参数合起来，可以写为-qo。

  3. 用rm命令可以把一些文件夹给删掉，比如，__MACOSX文件夹

  ```
  !cd data &&\

  unzip -qo data63004/Butterfly20_test.zip &&\

  unzip -qo data63004/Butterfly20.zip &&\

  rm -r __MACOSX
  ```  

- 接着，我们分析一下数据集，发现Butterfly20文件夹中有很多子文件夹，每个子文件夹下又有很多图片，每个子文件夹的名字都是蝴蝶属种的名字。由此，可以推测每个文件夹下是样本，而样本的标签就是子文件夹的名字。

  - 我们绘制data/Butterfly20/001.Atrophaneura_horishanus文件夹下的图片006.jpg。根据百度百科，Atrophaneura horishanus是凤蝶科、曙凤蝶属的一个物种。

  - 我们再绘制data/Butterfly20/002.Atrophaneura_varuna文件夹下的图片006.jpg。根据百度百科，Atrophaneura varuna对应的中文名称是“瓦曙凤蝶”，它是凤蝶科、曙凤蝶属的另一个物种。

  - 虽然乍一看蝴蝶都是相似的，但不同属种的蝴蝶在形状、颜色等细节方面还是存在很大的差别。

	```
	import matplotlib.pyplot as plt

	import PIL.Image as Image

	path='/home/aistudio/data/Butterfly20/001.Atrophaneura_horishanus/006.jpg'

	img = Image.open(path)

	plt.imshow(img)          #根据数组绘制图像

	plt.show()               #显示图像
	```

	```

	path='/home/aistudio/data/Butterfly20/002.Atrophaneura_varuna/006.jpg'

	img = Image.open(path)

	plt.imshow(img)          #根据数组绘制图像

	plt.show()               #显示图像

	```  
  
<div align="center">
<img src="ai_course_images/1.png">
</div>  


  - 更具挑战的是，即便属于同一属种，不同的蝴蝶图片在角度、明暗、背景、姿态、颜色等方面均存在不小差别。甚至有的图片里面有多只蝴蝶。以下两张蝴蝶图片均出自同一个属种Atrophaneura horishanus。

	```
	path1='/home/aistudio/data/Butterfly20/001.Atrophaneura_horishanus/006.jpg'

	path2='/home/aistudio/data/Butterfly20/001.Atrophaneura_horishanus/150.jpg'



	img1 = Image.open(path1)

	plt.imshow(img1)          #根据数组绘制图像

	plt.show()



	img2 = Image.open(path2)

	plt.imshow(img2)          #根据数组绘制图像

	plt.show()               #显示图像
	```
<div align="center">
<img src="ai_course_images/2.png">
<img src="ai_course_images/3.png">
</div>

## 4.准备数据
数据准备过程包括以下两个重点步骤：

- 一是建立样本数据读取路径与样本标签之间的关系。

- 二是构造读取器与数据预处理。可以写个自定义数据读取器，它继承于PaddlePaddle2.0的dataset类，在__getitem__方法中把自定义的预处理方法加载进去。

## 5. 建立模型
&emsp;&emsp;为了提升探索速度，建议首先选用比较成熟的基础模型，看看基础模型所能够达到的准确度。之后再试试模型融合，准确度是否有提升。最后可以试试自己独创模型。

&emsp;&emsp;为简便，这里直接采用101层的残差网络ResNet，并且采用预训练模式。为什么要采用预训练模型呢？因为通常模型参数采用随机初始化，而预训练模型参数初始值是一个比较确定的值。这个参数初始值是经历了大量任务训练而得来的，比如用CIFAR图像识别任务来训练模型，得到的参数。虽然蝴蝶识别任务和CIFAR图像识别任务是不同的，但可能存在某些机器视觉上的共性。用预训练模型可能能够较快地得到比较好的准确度。

&emsp;&emsp;在PaddlePaddle2.0中，使用预训练模型只需要设定模型参数pretained=True。值得注意的是，预训练模型得出的结果类别是1000维度，要用个线性变换，把类别转化为20维度。

## 6. 应用高阶API训练模型
- 一是定义输入数据形状大小和数据类型。

- 二是实例化模型。如果要用高阶API，需要用Paddle.Model()对模型进行封装，如model = paddle.Model(model,inputs=input_define,labels=label_define)。

- 三是定义优化器。这个使用Adam优化器，学习率设置为0.0001，优化器中的学习率(learning_rate)参数很重要。要是训练过程中得到的准确率呈震荡状态，忽大忽小，可以试试进一步把学习率调低。

- 四是准备模型。这里用到高阶API，model.prepare()。


- 五是训练模型。这里用到高阶API，model.fit()。参数意义详见下述代码注释。

## 7. 应用已经训练好的模型进行预测
&emsp;&emsp;如果是要参加建模比赛，通常赛事组织方会提供待预测的数据集，我们需要利用自己构建的模型，来对待预测数据集合中的数据标签进行预测。也就是说，我们其实并不知道到其真实标签是什么，只有比赛的组织方知道真实标签，我们的模型预测结果越接近真实结果，那么分数也就越高。

预测流程分为以下几个步骤：

- 一是构建数据读取器。因为预测数据集没有标签，该读取器写法和训练数据读取器不一样，建议重新写一个类，继承于Dataset基类。

- 二是实例化模型。如果要用高阶API，需要用Paddle.Model()对模型进行封装，如paddle.Model(MyNet(),inputs=input_define)，由于是预测模型，所以仅设定输入数据格式就好了。

- 三是读取刚刚训练好的参数。这个保存在/home/aistudio/work目录之下，如果指定的是final则是最后一轮训练后的结果。可以指定其他轮次的结果，比如model.load('/home/aistudio/work/30')，这里用到了高阶API，model.load()

- 四是准备模型。这里用到高阶API，model.prepare()。

- 五是读取待预测集合中的数据，利用已经训练好的模型进行预测。

- 六是结果保存。

